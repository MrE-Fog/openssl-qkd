#include <stdbool.h>
#include <string.h>
#include <openssl/bn.h>
#include <openssl/dh.h>
#include <openssl/engine.h>
#include <openssl/types.h>
#include "qkd_common.h"

void fatal(const char *format, ...)
{
    va_list argptr;
    va_start(argptr, format);
    vfprintf(stderr, format, argptr);
    va_end(argptr);
    exit(1);
}

void report_progress(const char *what, bool okay)
{
    if (okay) {
        fprintf(stderr, "%s: OK\n", what);
    } else {
        fatal("%s: FAILED\n", what);
    }
}

int shared_secret_nr_bytes(DH *dh)
{
    /* In real life the shared secret is a number between 1 and P-1, where P is the prime number
    parameter of Diffie-Hellman. The shared secret is generated by asking QKD for a key using the
    ETSI API. A realistic example is that we need 2048 bits = 256 bytes of shared secret. However,
    generating 2048 bits of key material would take waaaay too long in simulation, so if we are
    running on top of SimulaQron we only ask for 8 bytes of shared secret. */
    if (running_on_simulaqron) {
        return 8;
    } else {
        const BIGNUM *p;
        DH_get0_pqg(dh, &p, NULL, NULL);
        return BN_num_bytes(p);
    }
}

int engine_init(ENGINE *engine)
{
    printf("engine_init\n");
    return 1;
}

int engine_bind_common(ENGINE *engine, const char *engine_id, const char *engine_name, 
                       DH_METHOD *dh_method)
{
    printf("example_engine_bind\n");

    int result = ENGINE_set_id(engine, engine_id);
    report_progress("ENGINE_set_id", result != 0);
    
    result = ENGINE_set_name(engine, engine_name);
    report_progress("ENGINE_set_name", result != 0);

    result = ENGINE_set_DH(engine, dh_method);
    report_progress("ENGINE_set_DH", result != 0);

    result = ENGINE_set_init_function(engine, engine_init);
    report_progress("ENGINE_set_init_function", result != 0);

    return 1;
}

/**
 * qkd_engine_common.c
 * 
 * Code that is common to both OpenSSL engines: the server engine (qkd_server.c) and the client
 * engine (qkd_client.c).
 * 
 * (c) 2019 Bruno Rijsman, All Rights Reserved.
 * See LICENSE for licensing information.
 */

#include "qkd_engine_common.h"
#include "qkd_debug.h"
#include <assert.h>
#include <string.h>
#include <openssl/engine.h>

bool QKD_return_fixed_key_for_testing = true;
const unsigned long QKD_fixed_public_key = 1111;
const unsigned long QKD_fixed_private_key = 2222;

bool running_on_simulaqron = false;

/**
 * Convert an OpenSSL public key (which is stored as a big number) to an ETSI API key handle.
 * 
 * Returns 1 on success, 0 on failure (public key is too big for key handle).
 */
int QKD_bignum_to_key_handle(const BIGNUM *bn, QKD_key_handle_t *key_handle)
{
    int bn_num_bytes = BN_num_bytes(bn);
    if (bn_num_bytes > QKD_KEY_HANDLE_SIZE) {
        return 0;
    }
    int copied_bytes = BN_bn2bin(bn, (unsigned char *) key_handle->bytes);
    assert(copied_bytes == bn_num_bytes);
    int num_padding_bytes = QKD_KEY_HANDLE_SIZE - copied_bytes;
    memset((unsigned char *) key_handle->bytes + copied_bytes, 0, num_padding_bytes);
    return 1;
}

/**
 * Convert an ETSI API key handle to an OpenSSL public key (which is stored as a big number).
 *
 * Returns 1 on success, 0 on failure.
 */
int QKD_key_handle_to_bignum(const QKD_key_handle_t *key_handle, BIGNUM *bn)
{
    BIGNUM *result_bn = BN_bin2bn((unsigned char *) key_handle->bytes, QKD_KEY_HANDLE_SIZE, bn);
    assert(result_bn == bn);
    return 1;
}

/**
 * Convert a shared secret to a human readable string.
 * 
 * Returns a pointer to the human readable string on success, NULL on failure (memory allocation
 * failed)
 * 
 * Note: returns a pointer to a string that is overwritten on the next call to this function.
 */
char *QKD_shared_secret_str(unsigned char *shared_secret, size_t shared_secret_size)
{
    static char *str = NULL;
    static size_t str_size = 0;
    size_t needed_str_size = 2 * shared_secret_size + 1;
    if (str == NULL || str_size < needed_str_size) {
        str = realloc(str, needed_str_size);
        if (!str) {
            return NULL;
        }
        str_size = needed_str_size;

    }
    char *str_p = str;
    unsigned char *shared_secret_p = shared_secret;
    for (int i = 0; i < shared_secret_size; i++) {
        snprintf(str_p, 3, "%02x", *shared_secret_p);
        str_p += 2;
        shared_secret_p += 1;
    }
    *str_p = '\0';
    return str;
}

int shared_secret_nr_bytes(DH *dh)
{
    /* In real life the shared secret is a number between 1 and P-1, where P is the prime number
    parameter of Diffie-Hellman. The shared secret is generated by asking QKD for a key using the
    ETSI API. A realistic example is that we need 2048 bits = 256 bytes of shared secret. However,
    generating 2048 bits of key material would take waaaay too long in simulation, so if we are
    running on top of SimulaQron we only ask for 8 bytes of shared secret. */
    if (running_on_simulaqron) {
        return 8;
    } else {
        const BIGNUM *p;
        DH_get0_pqg(dh, &p, NULL, NULL);
        return BN_num_bytes(p);
    }
}

int engine_init(ENGINE *engine)
{
    QKD_enter();
    QKD_exit();
    return 1;
}

int QKD_engine_bind(ENGINE *engine, const char *engine_id, const char *engine_name, 
                       DH_METHOD *dh_method)
{
    QKD_enter();

    int result = ENGINE_set_id(engine, engine_id);
    QKD_fatal_if(result == 0, "ENGINE_set_id failed");
    
    result = ENGINE_set_name(engine, engine_name);
    QKD_fatal_if(result == 0, "ENGINE_set_name failed");

    result = ENGINE_set_DH(engine, dh_method);
    QKD_fatal_if(result == 0, "ENGINE_set_DH failed");

    result = ENGINE_set_init_function(engine, engine_init);
    QKD_fatal_if(result == 0, "ENGINE_set_init_function failed");

    QKD_exit();
    return 1;
}

#include "qkd_engine_common.h"

#include <stdbool.h>
#include <string.h>
#include <openssl/bn.h>
#include <openssl/dh.h>
#include <openssl/engine.h>
#include <openssl/types.h>
#include "qkd_debug.h"


bool QKD_return_fixed_key_for_testing = true;
const unsigned long QKD_fixed_public_key = 1111;
const unsigned long QKD_fixed_private_key = 2222;

bool running_on_simulaqron = false;


int shared_secret_nr_bytes(DH *dh)
{
    /* In real life the shared secret is a number between 1 and P-1, where P is the prime number
    parameter of Diffie-Hellman. The shared secret is generated by asking QKD for a key using the
    ETSI API. A realistic example is that we need 2048 bits = 256 bytes of shared secret. However,
    generating 2048 bits of key material would take waaaay too long in simulation, so if we are
    running on top of SimulaQron we only ask for 8 bytes of shared secret. */
    if (running_on_simulaqron) {
        return 8;
    } else {
        const BIGNUM *p;
        DH_get0_pqg(dh, &p, NULL, NULL);
        return BN_num_bytes(p);
    }
}

int engine_init(ENGINE *engine)
{
    QKD_enter();
    QKD_exit();
    return 1;
}

int engine_bind_common(ENGINE *engine, const char *engine_id, const char *engine_name, 
                       DH_METHOD *dh_method)
{
    QKD_enter();

    int result = ENGINE_set_id(engine, engine_id);
    QKD_fatal_if(result == 0, "ENGINE_set_id failed");
    
    result = ENGINE_set_name(engine, engine_name);
    QKD_fatal_if(result == 0, "ENGINE_set_name failed");

    result = ENGINE_set_DH(engine, dh_method);
    QKD_fatal_if(result == 0, "ENGINE_set_DH failed");

    result = ENGINE_set_init_function(engine, engine_init);
    QKD_fatal_if(result == 0, "ENGINE_set_init_function failed");

    QKD_exit();
    return 1;
}
